package NowCoder.LeetCode.Tags.Hot100.Array;

/**
 * 11. 盛最多水的容器：
 *  给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai)
 *  在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)
 *  找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水
 *
 *  例如：[1, 8, 6, 2, 5, 4, 8, 3, 7]
 *  在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
 *
 * TODO 错误思路：
 *      和进阶code_11类似，单调栈的问题
 *      找左右两边比它小的，从栈底到栈顶是从小到大
 *  这种解法是错误的，因为对于每个位置，要找的应该是离他最远且比他小的位置
 *  而单调栈找的是离他最近的位置
 *
 * TODO 注意：该题是木桶原理，需要注意的是如果中间有更短的板，是可以淹没该板的
 *  所以只需要考虑以左右两边的板作为边界时的最大容量即可
 *
 * 思路：
 *  前后双指针法
 *      双指针代表容器的两壁，以较短的一边作为此时容器能够盛下的最高的水位
 *      TODO 不需要考虑里面有更短的板的情况！！！
 *
 * TODO 需要考虑的问题：剪枝过程是否会丢掉最大值情况？
 *  注意事项：两个指针就是容器的两壁，只能选这两个指针中较小的高度，不需要关心容器内的高度
 *  (1) 解释1
 *  - 如果固定左边的指针，让右边的移动，那么根据上面注意事项，
 *    新的高度一定不会超过左边指针高度，新的高度只可能 <= 左边指针高度
 *  - 如果固定右边的指针，让左边的移动，同理，新的高度只可能 <= 右边指针高度
 *  此时，为了能够在指针向内移动时还能获取到较大的面积（因为指针内移，底是减小的）
 *  那么就要求以较高的一侧为边界，舍去较短的一侧。
 *  因为如果固定左边较短的一侧，而让右边较高的移动，那么水的高度一定不会超过左边高度，而底又在减小，
 *  因此面积一定是减小的。
 *  (2) 解释2
 *  一开始指针指向头和尾，此时容器的底是最大的
 *  当我们向内移动一个指针时，容器的底一定是减小的
 *  此时为了能够获得更大的面积，就必须让容器的高度增加
 *  因为两个指针固定了容器能够盛下的水的高度，所以为了确保能够获得更大的值
 *  必须让较高的一侧不动，而移动较小的一侧，才有可能在后续情况中使用较高一侧作为容器的高
 *
 */
public class code15_MaxArea {
    public static int maxArea(int[] arr){
        if (arr == null || arr.length < 2){
            return 0;
        }

        int i = 0;
        int j = arr.length - 1;

        int res = 0;

        while (i < j){
            if (arr[i] < arr[j]){
                res = Math.max(res, (j - i) * arr[i]);
                i++;
            }else {
                res = Math.max(res, (j - i) * arr[j]);
                j--;
            }
        }

        return res;
    }

    public static void main(String[] args) {
        int[] arr = {1, 8, 6, 2, 5, 4, 8, 3, 7};
        System.out.println(maxArea(arr)); // 49
    }
}
