package NowCoder.背包问题;

/*
01背包问题: TODO 每个物品只能使用一次, 1: 选择, 0: 不选择
    有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
    第 i 件物品的体积是 vi，价值是 wi。
    求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
    输出最大价值。

输入格式
    第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
    接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式
    输出一个整数，表示最大价值。
数据范围
    0<N,V≤1000
    0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8
 */
public class code01_01Package {

    /*
     普通动态规划:
         1. f[i][j]: 表示只看前i个物品, 选择的物品的总体积<=j, 总价值最大是多少
            i: 前i个物品 ==> 1~N
            j: 此时的背包总容量(体积) ==> 0~V

         2. result = max{f[n][0~V]}

         3. f[i][j]的几种可能性:
         假设前i-1个物品的状态都计算完, 现在考虑第i个物品, 剩余体积是j的时候的最大价值
         只需要看第i个物品有几种选择的可能性即可

         (1) 不选第i个物品 ==> 也可能是第i件物品比背包容量要大
         ==> 只考虑前i-1个物品, 且物品总体积<=j的时候的状态
         ==> f[i][j] = f[i-1][j]

         (2) 选第i个物品 ==> 潜在要求: 第i件物品体积小于等于背包总容量j
         ==> 那么首先要去除掉第i个物品的体积, 求剩余总体积(j-v[i])下的状态
         ==> 考虑完第i个物品后, 只需要考虑前i-1个物品的状态, 还得加上第i个物品的价值
         ==> f[i][j] = f[i - 1][j-v[i]] + w[i]
         TODO 如果当前选择了第i个物品后的总价值 < 之前i-1个物品的总价值的话, 则不选第i个物品
            ==> 需要进行max的判断

         ==> f[i][j] = max{f[i-1][j], f[i-1][j-v[i]] + w[i]}
            (从后往前推导, 实际计算从前往后计算)

         4. f[i][j] = max{1, 2}

         5. base case初始化 ==> f[0][0] = 0

         6. 时间复杂度: O(N*V)
            空间复杂度: O(N*V)
     */
    public static int process1(int[] v, int[] w, int N, int V){
        /*
            定义一个二阶矩阵dp[N+1][V+1],
            这里之所以要N+1和V+1，是因为第0行表示只能选择第0个物品的时候，即没有物品的时候
            第0列表示背包的体积为0的时候，即不能装任何东西的时候

            dp[i][j]表示在 只能选择前i个物品，背包容量为j的情况下，背包中物品的最大价值
            对于dp[i][j]有两种情况：
            1. 不选择当前的第i件物品/第i件物品比背包容量要大，则dp[i][j] = dp[i-1][j]
            2. 选择当前的第i件物品（潜在要求第i件物品体积小于等于背包总容量），则能装入的物品最大价值为：
                当前物品的价值 加上 背包剩余容量在只能选前i-1件物品的情况下的最大价值
                dp[i][j] = dp[i-1][j-v[i]] + w[i]
            dp[i][j]在两种情况中选择比较大的情况作为当前的最优解；
            即：
            if(j >= v[i]):
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
            else:
                dp[i][j] = dp[i-1][j]
        */
        int[][] dp = new int[N + 1][V + 1];

        // base case
        dp[0][0] = 0;

        for (int i = 1; i <= N; i++) { // 遍历N个物品
            for (int j = 0; j <= V; j++) { // 遍历当前物品的每个状态
                // 1
                dp[i][j] = dp[i - 1][j];
                // 2
                if (j >= v[i - 1]){
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - v[i - 1]] + w[i - 1]);
                }
            }
        }

//        int res = 0;
//        for (int j = 0; j < dp[0].length; j++) {
//            res = Math.max(res, dp[N][j]);
//        }
//
//        return res;
        return dp[N][V];
    }

    /*
    优化方法:
        外层循环是遍历1~N个物品, 内层循环是遍历0~V的体积
        根据推导公式: f[i][j] = max{f[i-1][j], f[i-1][j-v[i]] + w[i]}
        f[i][j]只和它之前的一个物品状态f[i-1][j]和f[i-1][j-v[i]]有关, 而不是和之前的所有物品有关
        所以每次可以只记录前一个物品的所有状态
        当遍历到当前第i个物品时, 就可以使用之前数组(第i-1个物品)中的状态

        ==> 一维数组表示

        f[j]: 表示体积是j时的最大价值

        外层循环: 遍历1~N个物品
        内层循环: 可以进行改写
            二维情况下: f[j] = Math.max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]), i表示1~N个物品
        ==> 一维情况下: 倒序遍历, f[j] = Math.max(f[j], f[j - v[i]] + w[i]), i表示1~N个物品

        TODO 这里的i-1其实就是当前dp一维数组中的值, 只不过现在需要依赖这些值来更新一维数组dp
            当计算第i个物品的各个状态时, 因为只有一维, 此时的dp记录的是第i-1个物品的各个状态
            而dp[i][j]又依赖于它前一个物品的状态
            如果依然从前往后遍历的话, 会导致数组前面的状态已经更新成第i个物品的状态, 而不是第i-1个物品的状态
            所以应该从后往前遍历, 每次依赖于数组前面的状态, 来更新数组后面的信息

        TODO 思想:
            当二维数组下每个位置只依赖于它上一层的值时, 可以降成一维数组从后往前遍历
            每次依赖前面的旧值, 更新后面成新值

     */
    public static int process2(int[] v, int[] w, int N, int V){
        // 只记录当前第i个物品的每个状态
        int[] dp = new int[V + 1];

        dp[0] = 0;

        for (int i = 1; i <= N; i++) { // 遍历N个物品
//            for (int j = V; j >= 0; j--) { // 遍历当前物品的每个状态
//                // 1
//                dp[j] = dp[j];
//                // 2 仅在当前总体积j >= 当前物品的体积v[i]时, 才更新
//                // TODO 可以将else的判断移除掉了, 因为这里进行判断的时候就是和其前一个物品的状态在进行判断
//                if (j >= v[i]) {
//                    dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
//                }
//            }
            // 优化, 由于dp[j]此时记录的是i-1的状态, 所以只需要在循环的条件来判断
            // 如果 j>=v[i], 那么我们才进入循环更新dp[j]的值(可能2), 否则就是 dp[j]原来的值(可能1)
            for (int j = V; j >= v[i]; j--) { // TODO 进入循环表示一定要选择第i个物品
                dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
            }
        }

//        int res = 0;
//        for (int j = 0; j < dp.length; j++) {
//            res = Math.max(res, dp[j]);
//        }
//
//        return res;
        return dp[V];
    }

    /*
    一个细节问题:
        如果题目要求恰好装满背包时价值最大, 则初始化时应该将除了0位置的值都设为最小值
        如果题目不要求装满背包, 则初始化时都设为0

    总结:
        处理第i个物品时, 01背包问题的模板
            for j: V -> v[i]
                f[j]=max(f[j], f[j-v[i]] + w[i])

        01背包问题
            for i: 1 -> N
                for j: V -> v[i]
                    f[j]=max(f[j], f[j-v[i]] + w[i])
     */

    public static void main(String[] args) {

        /*
        // 读入数据的代码
        Scanner sc = new Scanner(System.in);
        // 物品的数量为N
        int N = sc.nextInt();
        // 背包的容量为V
        int V = sc.nextInt();
        // 一个长度为N的数组，第i个元素表示第i个物品的体积；
        int[] v = new int[N + 1];
        // 一个长度为N的数组，第i个元素表示第i个物品的价值；
        int[] w = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }
        sc.close();

        System.out.println(process1(v, w, N, V));

//       System.out.println(process2(v, w, N, V));
         */

        int N = 4;
        int V = 5;
        // TODO 如果是Scanner, 那么要将v和w数组定义成N+1长度, 从1位置开始接收值
        int[] v = {1, 2, 3, 4};
        int[] w = {2, 4, 4, 5};

        System.out.println(process1(v, w, N, V)); // 8
    }

}
